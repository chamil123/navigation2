"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.LARGE_PANEL_CONTENT_HEIGHT = exports.SMALL_PANEL_CONTENT_HEIGHT = void 0;
const React = require("react");
const react_native_1 = require("react-native");
const Bar_1 = require("./Bar");
const Close_1 = require("./Close");
let FULL_HEIGHT = react_native_1.Dimensions.get('window').height;
let FULL_WIDTH = react_native_1.Dimensions.get('window').width;
let PANEL_HEIGHT = FULL_HEIGHT - 100;
const STATUS = {
    CLOSED: 0,
    SMALL: 1,
    LARGE: 2,
};
class SwipeablePanel extends React.Component {
    constructor(props) {
        super(props);
        this.componentDidMount = () => {
            const { isActive, openLarge, onlyLarge, onlySmall } = this.props;
            this.animatedValueY = 0;
            this.state.pan.y.addListener((value) => (this.animatedValueY = value.value));
            this.setState({ isActive });
            if (isActive)
                this._animateTo(onlySmall ? STATUS.SMALL : openLarge ? STATUS.LARGE : onlyLarge ? STATUS.LARGE : STATUS.SMALL);
            react_native_1.Dimensions.addEventListener('change', this._onOrientationChange);
        };
        this._onOrientationChange = () => {
            const dimesions = react_native_1.Dimensions.get('screen');
            FULL_HEIGHT = dimesions.height;
            FULL_WIDTH = dimesions.width;
            PANEL_HEIGHT = FULL_HEIGHT - 100;
            this.setState({
                orientation: dimesions.height >= dimesions.width ? 'portrait' : 'landscape',
                deviceWidth: FULL_WIDTH,
                deviceHeight: FULL_HEIGHT,
                panelHeight: PANEL_HEIGHT,
            });
            this.props.onClose();
        };
        this._animateTo = (newStatus = 0) => {
            let newY = 0;
            if (newStatus === STATUS.CLOSED)
                newY = PANEL_HEIGHT;
            else if (newStatus === STATUS.SMALL)
                newY = this.state.orientation === 'portrait' ? FULL_HEIGHT - 400 : FULL_HEIGHT / 3;
            else if (newStatus === STATUS.LARGE)
                newY = 0;
            this.setState({
                showComponent: true,
                status: newStatus,
            });
            react_native_1.Animated.spring(this.state.pan, {
                toValue: { x: 0, y: newY },
                tension: 80,
                friction: 25,
                useNativeDriver: true,
                restDisplacementThreshold: 10,
                restSpeedThreshold: 10,
            }).start(() => {
                if (newStatus === 0) {
                    this.props.onClose();
                    this.setState({
                        showComponent: false,
                    });
                }
                else
                    this.setState({ canScroll: newStatus === STATUS.LARGE ? true : false });
            });
        };
        this.state = {
            status: STATUS.CLOSED,
            isActive: false,
            showComponent: false,
            canScroll: false,
            opacity: new react_native_1.Animated.Value(0),
            pan: new react_native_1.Animated.ValueXY({ x: 0, y: FULL_HEIGHT }),
            orientation: FULL_HEIGHT >= FULL_WIDTH ? 'portrait' : 'landscape',
            deviceWidth: FULL_WIDTH,
            deviceHeight: FULL_HEIGHT,
            panelHeight: PANEL_HEIGHT,
        };
        this.pan = new react_native_1.Animated.ValueXY({ x: 0, y: FULL_HEIGHT });
        this.isClosing = false;
        this.animatedValueY = 0;
        this._panResponder = react_native_1.PanResponder.create({
            onStartShouldSetPanResponder: (evt, gestureState) => true,
            onPanResponderGrant: (evt, gestureState) => {
                this.state.pan.setOffset({
                    x: 0,
                    y: this.animatedValueY,
                });
                this.state.pan.setValue({ x: 0, y: 0 });
            },
            onPanResponderMove: (evt, gestureState) => {
                if ((this.state.status === 1 && Math.abs(this.state.pan.y._value) <= this.state.pan.y._offset) ||
                    (this.state.status === 2 && this.state.pan.y._value > -1))
                    this.state.pan.setValue({
                        x: 0,
                        y: gestureState.dy,
                    });
            },
            onPanResponderRelease: (evt, gestureState) => {
                const { onlyLarge, onlySmall } = this.props;
                this.state.pan.flattenOffset();
                if (gestureState.dy === 0)
                    this._animateTo(this.state.status);
                else if (gestureState.dy < -100 || gestureState.vy < -0.5) {
                    if (this.state.status === STATUS.SMALL)
                        this._animateTo(onlySmall ? STATUS.SMALL : STATUS.LARGE);
                    else
                        this._animateTo(STATUS.LARGE);
                }
                else if (gestureState.dy > 100 || gestureState.vy > 0.5) {
                    if (this.state.status === STATUS.LARGE)
                        this._animateTo(onlyLarge ? STATUS.CLOSED : STATUS.SMALL);
                    else
                        this._animateTo(0);
                }
                else
                    this._animateTo(this.state.status);
            },
        });
    }
    componentDidUpdate(prevProps, prevState) {
        const { isActive, openLarge, onlyLarge, onlySmall } = this.props;
        // if (onlyLarge && onlySmall)
        //   console.warn(
        //     'Ops. You are using both onlyLarge and onlySmall options. onlySmall will override the onlyLarge in this situation. Please select one of them or none.',
        //   );
        if (prevProps.isActive !== isActive) {
            this.setState({ isActive });
            if (isActive) {
                this._animateTo(onlySmall ? STATUS.SMALL : openLarge ? STATUS.LARGE : onlyLarge ? STATUS.LARGE : STATUS.SMALL);
            }
            else {
                this._animateTo();
            }
        }
        if (prevState.orientation !== this.state.orientation)
            this._animateTo(this.state.status);
    }
    render() {
        const { showComponent, deviceWidth, deviceHeight, panelHeight } = this.state;
        const { noBackgroundOpacity, style, barStyle, closeRootStyle, closeIconStyle, onClose, allowTouchOutside, closeOnTouchOutside, } = this.props;
        return showComponent ? (<react_native_1.Animated.View style={[
            SwipeablePanelStyles.background,
            {
                backgroundColor: noBackgroundOpacity ? 'rgba(0,0,0,0)' : 'rgba(0,0,0,0.5)',
                height: allowTouchOutside ? 'auto' : deviceHeight,
                width: deviceWidth,
            },
        ]}>
        {closeOnTouchOutside && (<react_native_1.TouchableWithoutFeedback onPress={() => onClose()}>
            <react_native_1.View style={[
            SwipeablePanelStyles.background,
            {
                width: deviceWidth,
                backgroundColor: 'rgba(0,0,0,0)',
                height: allowTouchOutside ? 'auto' : deviceHeight,
            },
        ]}/>
          </react_native_1.TouchableWithoutFeedback>)}
        <react_native_1.Animated.View style={[
            SwipeablePanelStyles.panel,
            {
                width: this.props.fullWidth ? deviceWidth : deviceWidth - 50,
                height: panelHeight,
            },
            { transform: this.state.pan.getTranslateTransform() },
            style,
        ]} {...this._panResponder.panHandlers}>
          {!this.props.noBar && <Bar_1.Bar barStyle={barStyle}/>}
          {this.props.showCloseButton && (<Close_1.Close rootStyle={closeRootStyle} iconStyle={closeIconStyle} onPress={this.props.onClose}/>)}
          <react_native_1.ScrollView onTouchStart={() => {
            return false;
        }} onTouchEnd={() => {
            return false;
        }} contentContainerStyle={SwipeablePanelStyles.scrollViewContentContainerStyle}>
            {this.state.canScroll ? (<react_native_1.TouchableHighlight>
                <React.Fragment>{this.props.children}</React.Fragment>
              </react_native_1.TouchableHighlight>) : (this.props.children)}
          </react_native_1.ScrollView>
        </react_native_1.Animated.View>
      </react_native_1.Animated.View>) : null;
    }
}
const SwipeablePanelStyles = react_native_1.StyleSheet.create({
    background: {
        position: 'absolute',
        zIndex: 1,
        bottom: 0,
        justifyContent: 'center',
        alignItems: 'center',
        backgroundColor: 'rgba(0,0,0,0.5)',
    },
    panel: {
        position: 'absolute',
        height: PANEL_HEIGHT,
        width: FULL_WIDTH - 50,
        transform: [{ translateY: FULL_HEIGHT - 100 }],
        display: 'flex',
        flexDirection: 'column',
        backgroundColor: 'white',
        bottom: 0,
        borderTopLeftRadius: 20,
        borderTopRightRadius: 20,
        borderBottomLeftRadius: 0,
        borderBottomRightRadius: 0,
        overflow: 'hidden',
        shadowColor: '#000',
        shadowOffset: {
            width: 0,
            height: 1,
        },
        shadowOpacity: 0.18,
        shadowRadius: 1.0,
        elevation: 1,
        zIndex: 2,
    },
    scrollViewContentContainerStyle: {
        width: '100%',
    },
});
exports.default = SwipeablePanel;
exports.SMALL_PANEL_CONTENT_HEIGHT = PANEL_HEIGHT - (FULL_HEIGHT - 400) - 25;
exports.LARGE_PANEL_CONTENT_HEIGHT = PANEL_HEIGHT - 25;
